/* Класс Food - еда:
 члены этого класса calories - калорийность и weight - вес
 Их еще называют - атрибуты объекта, переменные объекта или поля. */
open class Food {
    val calories: Int
    val weight: Float

    /*     Чтобы создать объект этого класса, и сразу поместить в поля требуемые нам значения, создаём конструктор.
         Он получает значения в параметрах calories и weight, затем присваивает их полям класса. */
    constructor(calories: Int, weight: Float) {
        this.calories = calories
        this.weight = weight
    }
}

/* Теперь можно будет создать объект класса Food (210 кКал, 0.5 килограмма) таким образом
 val колбаска = Food(210, 0.5f)
 Модификатор open используется для того, чтобы указать, что от этого класса можно наследовать. */



/*  Класс Drink - питьё. Поля: calories - калорийность, volume - объём
 Допускается совместить объявление класса и первичный конструктор.
 Здесь в круглых скобках перечислены параметры конструктора calories и volume */
class Drink(calories: Int, volume: Float) {
    /*   При создании класса вызывается конструктор Drink(calories, volume)
         в параметре поле calories находится какое-то значение,
         теперь помещаем это значение в поле calories   */
    val calories: Int = calories

    //А в поле volume помещаем значение, которое передано в параметре volume
    val volume: Float = volume
}

/* Теперь можно создать объект класса Drink (64 кКал, 0.5 литра) таким образом
 val молочко = Drink(42, 0.5f) */



/*  Класс Toy - игрушка, поля calories - сколько калорий тратиться за 10 минут,
 и time - сколько времени питомец играл с предметом.
 Можно совместить объявление класса, первичный конструктор и поля класса вот так:  */
class Toy(val calories: Int, val time: Int)

/*  Теперь можно создать объект класса Toy (10 кКал, 5 минут)
 val бантик = Toy(10, 5)  */

// Можно использовать data классы, они имеют некоторые особенности, о них позже
// Вот класс Bowl - миска с атрибутом volume - объём
data class Bowl(val volume: Float)
// val мискаКота =  Bowl(12f) // 12 литров


//Для параметров и полей можно указать значение по умолчанию, вот так:
data class Sweets(val calories: Int = 1500, val weight: Float = 5f)
//Теперь создать экземпляр класса Sweet можно таким образом:
// val конфета1 = Sweets(400, 0.5f), здесь calories = 400, weight = 0.5f
// val конфета2 = Sweets(600), здесь calories = 600, weight = 5f
// val конфета3 = Sweets() здесь calories = 1500, weight = 5f


// Теперь рассмотрим наследование,
// У нас есть сухой корм - это вид еды Food()
// Создадим класс DryFood и наследуем его от класса Food,
// для этого нам потребовалось добавить к объявлению класса Food модификатор open

class DryFood(calories: Int, weight: Float) : Food(calories, weight)

// Обратите внимание, что если у класса, которому мы наследуем, имеется конструкторы,
// мы должны вызвать один из них.
// Здесь у класса DryFood имеется конструктор DryFood(calories, weight),
// и при создании экземпляра класса DryFood он вызовет конструктор
// родительского класса (говорят еще суперкласса) Food(calories, weight),
// передав ему значения своих параметров calories и weight.
// val пегги = DryFood(400, 1f)


// Создадим класс Pet с атрибутами имя, вес, сытость и жажду питомца.
// Обратите внимание, переменные weight, satiety, thirst объявлены, как var, что означает, что они могут быть изменены.
// Значение name может быть задано лишь однажды, при создании экземпляра класса, потому что name объявлено, как val
// Кроме того класс будет иметь члены класса - методы  есть   и   пить,
// предположим, что они как-то меняют значения веса weight, сытости satiety и жажды thirst
open class Pet(var weight: Float, val name: String, var satiety: Float, var thirst: Float) {
    open fun eat(food: Food) { /*здесь код, вычисляющий как измениться сытость и вес от того, что было съедено food*/
    } //есть

    fun drink(drink: Drink) {} //пить
}
// можно создать экземпляр этого класса val myPet = Pet(22f, "Бобик", 5f, 5f)

// Теперь создадим подвид питомца. Это будет класс Cat, который наследуется от Pet.
// Используем запись вида class Наследник:КлассРодитель.
// Чтобы показать, что от Pet можно наследовать - потребовалось сделать Pet open.
class Cat(weight: Float, name: String, satiety: Float, thirst: Float) : Pet(weight, name, satiety, thirst) {
    // Теперь, у нас другие вычисления для метода eat, поэтому его требуется переопределить.
    // Для этого в родительском классе потребовалось объявить этот метод, как open,
    // а в этом, наследуемом классе, для метода использовать модификатор override.
    override fun eat(food: Food) { /*здесь новый код, вычисляющий как измениться сытость и вес от того, что было съедено food*/
    } //е

    //метод drink не переопределяем
}

// Теперь можно создать экземпляр класса Cat
// val мойКот = Cat(1.5f, "Бантик", 0f, 1f)
// вызвать методы
// мойКот.eat(колбаска)
// мойКот.drink(молочко)
// и обратиться к переменной экземпляра println(мойКот.name)

// Класс-родитель может быть абстрактным,
// то есть иметь только прототипы методов, без их описания.
// Обязанность реализации этих методов возлагается на наследников.
abstract class Bird(val name: String, var satiety: Float, var thirst: Float) {
    fun eat(food: Food) { /*расчёт сытости*/
    }

    abstract fun drink(drink: Drink) //расчёт жажды,
    // этот метод абстрактный, он требует реализации в каждом классе-наследнике
}

// Абстрактные классы не могут иметь экземпляров
// нельзя val kesha =  Bird("Кеша", 10, 10)


// Класс Parrot наследник Bird
class Parrot(name: String, satiety: Float, thirst: Float) : Bird(name, satiety, thirst) {
    override fun drink(drink: Drink) {
        /*расчёт жажды*/
    }
}

// теперь можно
// val kesha =  Parrot("Кеша", 10, 10)
// kesha.eat(просо)
// kesha.drink(вода)

// Классы могут иметь только один родительский класс. Говорят, что классы имеют одиночное наследование.


// Интерфейсы содержат прототипы методов и методы с реализацией по умолчанию
// Интерфейс - определяет что объекты могут делать.
interface Action {
    //спать - метод с реализацией по умолчанию
    fun sleep(time: Int) {
        println("Я сплю!")
    }

    //гулять - прототип метода, он абстрактный
    fun walk(time: Int)
}


// Создадим класс Dog, который Pet и умеет Action
class Dog(weight: Float, name: String, satiety: Float, thirst: Float) : Pet(weight, name, satiety, thirst), Action {
    override fun walk(time: Int) {
        /*Я гуляю*/
    }

    // Можно, если потребуется, переопределить метод sleep
    override fun sleep(time: Int) {
        super.sleep(time) // здесь вызван тот метод, что определён в родителе
    }

    // Класс может иметь и другие, собственные, методы и поля -

    // Громкость
    var velocity: Float = 0f

    fun voice() {
        /*подать голос*/
    }
}

//класс может иметь блоки инициализации переменных init{ ... }
class Calories(calories: Int) {
    //начальная инициализация переменной начальным значением
    private val calories0: Int = 200

    //этим переменным будет присвоены значение в блоке init
    private val calories1: Float
    private val calories2: Float
    private val calories3: Float

    init {
        calories1 = (calories + calories0) / 2.0f
        calories2 = (calories + calories1) / 2.0f
        calories3 = (calories + calories2) / 3.0f
    }

    private var weight: Float = 50f

    //второй конструктор, с двумя параметрами calories и weight
    constructor(calories: Int, weight: Float) : this(calories) {
        this.weight = weight
    }
}

//порядок выполнения
//сначала выполняется присвоение значений переменным при их инициализации
//потом выполняется блок инициализации init{}
//затем выполняется конструктор.

// соберём примеры вместе
fun main() {
    val колбаска = Food(210, 1f)
    val молочко = Drink(42, 0.5f)

    val бантик = Toy(10, 5)

    val мискаКота = Bowl(12f)

    val конфета1 = Sweets(400, 0.5f) // здесь calories = 400, weight = 0.5f
    val конфета2 = Sweets(600) // здесь calories = 600, weight = 5f
    val конфета3 = Sweets() //здесь calories = 1500, weight = 5f

    val пегги = DryFood(400, 1f)

    val myPet = Pet(22f, "Бобик", 5f, 5f)
    val мойКот = Cat(1.5f, "Бантик", 0f, 1f)
    мойКот.eat(колбаска)
    мойКот.drink(молочко)
    println(мойКот.name)


    // Что умеет объект класса Dog?
    val myDog = Dog(4.5f, "Чаппа", 20f, 5f)
    // от Pet наследуются:
    myDog.drink(молочко)
    myDog.eat(колбаска)
    // пегги - объект класс DryFood, наследника Food,
    // а функция eat объявлена, как eat(food:Food), поэтому мы можем передать пегги в качестве параметра этой функции
    myDog.eat(пегги)
    val w = myDog.weight
    val s = myDog.satiety
    val th = myDog.thirst
    val name = myDog.name

    // от Action
    myDog.sleep(12)
    myDog.walk(5)

    // собственный метод
    myDog.voice()

    // собственное поле
    myDog.velocity = 1f


    // Можно создавать объекты, задающие реализацию интерфейсов,
    // например здесь мы создаём объект, реализующий интерфейс Action
    // определяя все прототипы функций этого интерфейса
    val animal = object : Action {
        override fun walk(time: Int) {
            /*здесь что-то делается*/
        }
    }

    // Теперь мы можем
    animal.sleep(12)
    animal.walk(32)


    // Можно создать массив родительского типа Pet
    // и поместить туда экземпляры классов-наследников:
    // экземпляры класса Dog, и экземпляры класса Cat, и экземпляры класса Pet
    val array: Array<Pet> = arrayOf(myDog, мойКот, myPet)

    // Можно создать массив для объектов типа Action, и поместить туда экземпляры классов-наследников.
    val array2: Array<Action> = arrayOf(myDog, animal)

    //======================================================================
    // переменные, экземпляры на примере класса File

    // объявляем переменную  file типа java.io.File
    val file: java.io.File
    // здесь java, java.io - это пакеты библиотеки java
    // java.io.File - полное название класса, который находится в пакете java.io
    // чтобы не указывать полное название класса, а только его имя, можно выполнить импорт класса

    // А так создаём объект класса File, для этого вызываем конструктор класса и передаём ему строку в которой описан путь к файлу
    // Здесь создаётся экземпляр класса File, но никак не используется.
    java.io.File("resources/Wizard.txt")


    // Инициализируем переменную, помещаем в неё экземпляр, созданный конструктором File(...)
    file = java.io.File("resources/Wizard.txt")

    //можно совместить объявление переменной и инициализацию
    val file1 = java.io.File("resources/Wizard.txt")
    // Обратите внимание, если из выражения в правой части оператора присвоения =  можно получить информацию
    // о типе результата, то тип переменной указывать не обязательно.

}


